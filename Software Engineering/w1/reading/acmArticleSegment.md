# ACM: What is Software Engineering?

- Source: [ACM Software Engineering Curriculum Guideline](https://www.acm.org/binaries/content/assets/education/se2014.pdf)

## 2.1 Defining Software Engineering

Since the dawn of electronic computing in the 1940s, computing systems and their applications have evolved at a staggering rate. Software plays a central and underpinning role in almost all aspects of daily life: communications, government, manufacturing, banking and finance, education, transportation, entertainment, medicine, agriculture, and law. The number, size, and application domains of computer programs have grown dramatically; as a result, huge sums are being spent on software development [OECD 2010]. Most people’s lives and livelihoods depend on this development’s effectiveness. Software products help us to be more efficient and productive. They provide information, make us more effective problem solvers, and provide us with safer, more flexible, and less confining work, entertainment, and recreation environments.

Despite these successes, this period has witnessed serious problems in terms of the development costs, timeliness, and quality of many software products. There are many reasons for these problems:

- Software products are among the most complex manmade systems, and by its very nature, software has intrinsic, essential properties (for example, complexity, invisibility, and changeability) that are not easily addressed [Brooks 1987].
- Programming techniques and processes that work effectively when used by an individual or small team to develop modest-sized programs do not scale well to the development of large, complex systems. (Complexity can arise with just a few hundred lines of code, and large systems can run to millions of lines of code, requiring years of work by hundreds of software developers.)
- The pace of change in computer and software technology drives the demand for new and evolved software products. This situation has created customer expectations and competitive forces that strain our ability to produce quality software within acceptable development schedules.
- The availability of qualified software engineers has not kept pace with the demand from industry, so that systems are designed and built by people with insufficient educational background or experience.

The term “software engineering” [Naur 1969] has now become widely used in industry, government, and academia. Hundreds of thousands of computing professionals go by the title “software engineer”; numerous publications, groups and organizations, and professional conferences use the term software engineering in their names; and many educational courses and programs on software engineering are available. Unfortunately, as with the term “engineer” itself, the term software engineer is not always used to mean “a software engineering professional,” although that is the meaning that is assumed throughout this document.

Over this same period, although the software engineering discipline has evolved, the context has changed as well. In the 1960s, a software product was usually created as a single, monolithic entity, executed on a computer with the support of a fairly basic operating system. Such a product had external operations that were mainly confined to basic file input/output. In contrast, a software system developed in today may well reuse major components of other systems, execute on multiple machines and platforms, and interact with other, globally distributed systems [da Silva 2012].

Thus, although the current generation of software engineers undertake many of the same activities as their predecessors, they are likely to do so in a more complex environment. In addition, the consequences of any changes made to a system in the 1960s were likely to be localized, whereas now there may be truly global effects.

Over the years, ideas about what exactly software engineering is have also evolved. Nevertheless, a common thread exists that states (or strongly implies) that software engineering is more than just programming; it includes attention to details such as quality, schedule, and economic goals. Hence, a professional software developer needs both knowledge of such principles and experience with applying them.

The fact that the literature contains many different definitions of software engineering implies that a concise and complete definition of software engineering is difficult to formulate. This is largely because the interpretation of any definition requires an understanding, not only of the unique characteristics of software, but also of how “engineering” concepts must be adapted to address those characteristics.

The IEEE’s 2010 definition states that software engineering is "The application of a systematic, disciplined, quantifiable approach to the development, operation and maintenance of software; that is, the application of engineering to software." [IEEE 2010] The nature of software, however, complicates the interpretation of these words [Brooks 1987]. To address this ambiguity, it is helpful to identify some key characteristics of software and the associated challenges that they create for any form of “engineering” process.

- Software is abstract and invisible. These characteristics present challenges for managing software development because of the problems they create for important engineering concepts such as quantification and measurement. They also complicate efforts to describe and organize software in ways that will facilitate knowledge exchange during the processes of its design, implementation, and maintenance.
- Software has both static and dynamic properties. This duality provides a further challenge for description and measurement. It also makes it difficult to predict the effects arising from any changes made to a software product.
- Software is intrinsically complex in terms of its organization. Even a small software unit may possess many different execution paths, and there may be a large and complex set of relationships among its elements. This in turn presents challenges for verification and validation, documentation, and maintenance.
- No universal measures of quality exist for assessing a software product [Hughes 2000]. An engineering process should lead to products that are of “good” quality, but the relative importance of different quality measures will vary with the role of the product and differ for each stakeholder (producer, customer, or user).
- The manufacturing cycle for software products is not a significant element in software development, and it mainly involves the needs of distribution mechanisms. Software development is essentially a process that involves a progression through many layers of design abstraction and, hence, is unlike any conventional engineering processes, such as those that occur within mechanical and civil engineering.
- Software does not wear out. The maintenance activities associated with a software product are really part of an evolutionary design process.

Essentially therefore, software engineering practices are largely concerned with managing relevant processes and with design activities, and these can appear in a range of guises. Most of the activities involved in software development and evolution tend to use team-based processes that embody some form of design element, spanning from an initial choice of a high-level architecture through the choices of test and evaluation strategies. Each of these adds yet another layer of complication: teams must be organized with regard to aspects such as communication, coordination, and management and design activities are nondeterministic (or “wicked”) processes that lead to solutions that are rarely right or wrong [Rittel & Webber 1984; Peters & Tripp 1976]. Finally, there are also many different measures of quality that can be employed when assessing the different choices involved.
